From 3c32161fff761051d66fc2c8011626ae7768af74 Mon Sep 17 00:00:00 2001
From: djc <daron.chabot@gmail.com>
Date: Mon, 27 Feb 2012 17:33:38 -0500
Subject: [PATCH 5/5] Hack around initialization problem.

Following a power-cycle, the motor record reports the drives
as 'moving'. This is due to the initial response to the '?'
command (report status), returning 0x840040:
mtr activated,amplifier disabled,open-loop mode,phased mtr
(commutated by PMAC).

After a 'stop->go' sequence from the mtr record interface
(this sends a '#m J\' command: 'jog stop'; also restores
closed-loop mode), control-ability is restored.

Also reformat some lines.
---
 pmacApp/pmacAsynMotorSrc/pmacAsynMotor.c |   76 +++++++++++++++---------------
 1 files changed, 38 insertions(+), 38 deletions(-)

diff --git a/pmacApp/pmacAsynMotorSrc/pmacAsynMotor.c b/pmacApp/pmacAsynMotorSrc/pmacAsynMotor.c
index 13bc7f8..de56ee7 100644
--- a/pmacApp/pmacAsynMotorSrc/pmacAsynMotor.c
+++ b/pmacApp/pmacAsynMotorSrc/pmacAsynMotor.c
@@ -956,19 +956,19 @@ static void drvPmacGetAxisStatus( AXIS_HDL pAxis, asynUser * pasynUser, epicsUIn
 	    pAxis->previous_position = position_with_error;
 	    pAxis->previous_direction = direction;
 
-            if(pAxis->deferred_move) {
-                done = 0;
-            } else {
-                done = (((status[1] & PMAC_STATUS2_IN_POSITION) != 0) || ((status[0] & PMAC_STATUS1_MOTOR_ON) == 0));
-            }
-            motorParam->setInteger( pAxis->params, motorAxisDone,          done );
-            motorParam->setInteger( pAxis->params, motorAxisHighHardLimit, ((status[0] & PMAC_STATUS1_POS_LIMIT_SET) != 0) );
-            /*motorParam->setInteger( pAxis->params, motorAxisHomeSignal,    homeSignal );*/
-	    motorParam->setInteger( pAxis->params, motorAxisHomed,    homeSignal );
-            motorParam->setInteger( pAxis->params, motorAxisMoving,        ((status[0] & PMAC_STATUS1_DESIRED_VELOCITY_ZERO) == 0) && ((status[0] & PMAC_STATUS1_MOTOR_ON) != 0) );
-            motorParam->setInteger( pAxis->params, motorAxisLowHardLimit,  ((status[0] & PMAC_STATUS1_NEG_LIMIT_SET)!=0) );
-	    motorParam->setInteger( pAxis->params, motorAxisFollowingError,((status[1] & PMAC_STATUS2_ERR_FOLLOW_ERR)!=0) );
-            motorParam->callCallback( pAxis->params );
+          if(pAxis->deferred_move) {
+              done = 0;
+          } else {
+              done = (((status[1] & PMAC_STATUS2_IN_POSITION) != 0) || ((status[0] & PMAC_STATUS1_MOTOR_ON) == 0));
+          }
+          motorParam->setInteger( pAxis->params, motorAxisDone,          done );
+          motorParam->setInteger( pAxis->params, motorAxisHighHardLimit, ((status[0] & PMAC_STATUS1_POS_LIMIT_SET) != 0) );
+          /*motorParam->setInteger( pAxis->params, motorAxisHomeSignal,    homeSignal );*/
+          motorParam->setInteger( pAxis->params, motorAxisHomed,    homeSignal );
+          motorParam->setInteger( pAxis->params, motorAxisMoving,        ((status[0] & PMAC_STATUS1_DESIRED_VELOCITY_ZERO) == 0) && ((status[0] & PMAC_STATUS1_MOTOR_ON) != 0) );
+          motorParam->setInteger( pAxis->params, motorAxisLowHardLimit,  ((status[0] & PMAC_STATUS1_NEG_LIMIT_SET)!=0) );
+          motorParam->setInteger( pAxis->params, motorAxisFollowingError,((status[1] & PMAC_STATUS2_ERR_FOLLOW_ERR)!=0) );
+          motorParam->callCallback( pAxis->params );
         }
 
 #ifdef REMOVE_LIMITS_ON_HOME
@@ -1023,7 +1023,7 @@ static void drvPmacGetAxisInitialStatus( AXIS_HDL pAxis, asynUser * pasynUser )
     /* Read all the status for this axis in one go */
     if (epicsMutexLock( pAxis->axisMutex ) == epicsMutexLockOK)
     {
-        sprintf( command, "I%d13 I%d14 I%d30 I%d31 I%d33", pAxis->axis, pAxis->axis, pAxis->axis, pAxis->axis, pAxis->axis );
+        sprintf( command, "#%d J/ I%d13 I%d14 I%d30 I%d31 I%d33", pAxis->axis, pAxis->axis, pAxis->axis, pAxis->axis, pAxis->axis, pAxis->axis );
         cmdStatus = motorAxisWriteRead( pAxis, command, sizeof(response), response, 1 );
         nvals = sscanf( response, "%lf %lf %lf %lf %lf", &high_limit, &low_limit, &pgain, &dgain, &igain );
 
@@ -1034,13 +1034,13 @@ static void drvPmacGetAxisInitialStatus( AXIS_HDL pAxis, asynUser * pasynUser )
         }
         else
         {
-            motorParam->setDouble(  pAxis->params, motorAxisLowLimit,  low_limit*pAxis->scale );
-            motorParam->setDouble(  pAxis->params, motorAxisHighLimit, high_limit*pAxis->scale );
-            motorParam->setDouble(  pAxis->params, motorAxisPGain,     pgain );
-            motorParam->setDouble(  pAxis->params, motorAxisIGain,     igain );
-            motorParam->setDouble(  pAxis->params, motorAxisDGain,     dgain );
-	        motorParam->setDouble(  pAxis->params, motorAxisHasEncoder, 1);
-            motorParam->callCallback( pAxis->params );
+          motorParam->setDouble(  pAxis->params, motorAxisLowLimit,  low_limit*pAxis->scale );
+          motorParam->setDouble(  pAxis->params, motorAxisHighLimit, high_limit*pAxis->scale );
+          motorParam->setDouble(  pAxis->params, motorAxisPGain,     pgain );
+          motorParam->setDouble(  pAxis->params, motorAxisIGain,     igain );
+          motorParam->setDouble(  pAxis->params, motorAxisDGain,     dgain );
+          motorParam->setDouble(  pAxis->params, motorAxisHasEncoder, 1);
+          motorParam->callCallback( pAxis->params );
         }
         epicsMutexUnlock( pAxis->axisMutex );
     }
@@ -1221,26 +1221,26 @@ int pmacAsynMotorCreate( char *port, int addr, int card, int nAxes )
 
     if (status == MOTOR_AXIS_OK)
     {
-        int i;
+       int i;
 
-        /* Do an initial poll of all status */
-	for ( i = 0; i < pDrv->nAxes; i++ )
-	{
-            AXIS_HDL pAxis = &(pDrv->axis[i]);
+      /* Do an initial poll of all status */
+      for ( i = 0; i < pDrv->nAxes; i++ )
+      {
+        AXIS_HDL pAxis = &(pDrv->axis[i]);
 
-            drvPmacGetAxisInitialStatus( pAxis, pDrv->pasynUser );
-            drvPmacGetAxisStatus( pAxis, pDrv->pasynUser, 0 );
-        }
+        drvPmacGetAxisInitialStatus( pAxis, pDrv->pasynUser );
+        drvPmacGetAxisStatus( pAxis, pDrv->pasynUser, 0 );
+      }
 
-        pDrv->motorThread = epicsThreadCreate( "drvPmacThread",
-                                               epicsThreadPriorityLow,
-                                               epicsThreadGetStackSize(epicsThreadStackMedium),
-                                               (EPICSTHREADFUNC) drvPmacTask, (void *) pDrv );
-        if (pDrv->motorThread == NULL)
-        {
-            asynPrint(pDrv->pasynUser, ASYN_TRACE_ERROR, "Cannot start motor polling thread\n" );
-            return MOTOR_AXIS_ERROR;
-        }
+      pDrv->motorThread = epicsThreadCreate( "drvPmacThread",
+                                             epicsThreadPriorityLow,
+                                             epicsThreadGetStackSize(epicsThreadStackMedium),
+                                             (EPICSTHREADFUNC) drvPmacTask, (void *) pDrv );
+      if (pDrv->motorThread == NULL)
+      {
+        asynPrint(pDrv->pasynUser, ASYN_TRACE_ERROR, "Cannot start motor polling thread\n" );
+        return MOTOR_AXIS_ERROR;
+      }
     }
 
     return status;
-- 
1.7.0.4

